# # You are given a 3×3 grid of integers. 

# # Let Gi,j denote the integer in the i-th row and j-th column of the grid, where i and j are 0-indexed. 

# # The integer in the middle of the grid, G1,1, is missing. 

# # Find the maximum number of rows, columns, and diagonals of this square, that form sequences which are arithmetic progressions. 
# # You can replace the missing number with any integer.

# # An arithmetic progression (also known as arithmetic sequence) is a sequence of numbers such that the difference between consecutive terms is constant. 
# # In mathematical terms, this can be represented as an=an−1+d, where d is the common difference. 

# # In this problem, a sequence can be the 3 numbers in either a row, column or diagonal. 

# # We are looking to replace the missing value by an integer that maximizes the number of arithmetic progressions that can be found in the resulting set of sequences.

# # Two sequences are considered different if they are from different rows, columns, or diagonals. For example, the sequence {2,4,6}
# # across the middle row and {2,4,6} across the top row will be counted as two sequences but the sequences {2,4,6} and {6,4,2}
# # across the same row, column, or diagonal will be counted as one sequence.

# # Input
# # The first line of the input gives the number of test cases, T. T test cases follow.
# # Each test case consists of 3 lines.
# # The first line of each test case contains 3 integers, G0,0, G0,1, and G0,2.
# # The second line of each test case contains 2 integers, G1,0 and G1,2.
# # The last line of each test case contains 3 integers, G2,0, G2,1, and G2,2.
# # Output

# # For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and 
# # y is the maximum possible number of arithmetic progressions that can be generated by the rows, columns, and diagonals of the grid after setting the missing element. 

# import math

# def solve(testcases):
#     # print("solve: {}".format(testcases))

#     for testcase in range(testcases):
#         # row1 = [int(s) for s in input().split(" ")] # read a list of integers
#         # row2 = [int(s) for s in input().split(" ")]
#         # row2.insert(1, False)
#         # row3 = [int(s) for s in input().split(" ")]
#         row1 = [int(s) for s in file.readline().rstrip().split()] # read a list of integers
#         row2 = [int(s) for s in file.readline().rstrip().split()]
#         row2.insert(1, False)
#         row3 = [int(s) for s in file.readline().rstrip().split()]

#         grid = [row1, row2, row3]

#         # print(grid)

#         total = 0

#         # from left to right, top to bottom
#         for i, row in enumerate(grid):
#             # 7 cases

#             # row1 -> row1, col1, col2, col3, dia1, dia2
#             # row2 -> row2
#             # row3 -> row3

#             # ez -> row1, col1, row3, col3
#             row_count = 0
#             col_count = 0
#             special_count = 0
#             if i != 1: 
#                 row_count = countRow(row)

#                 if i == 0:
#                     col_count += countCol(grid)
#             else:
#                 special_count = countSpecial(grid)

#             total += (row_count + col_count + special_count)

#         print("Case #{0}: {1}".format(testcase + 1, total))

            

# def countSpecial(grid):
#     # print("special case")

#     counts = {}
#     vals = [(grid[0][0], grid[2][2]), (grid[0][2], grid[2][0]), (grid[0][1],grid[2][1]), (grid[1][0],grid[1][2])]
    
#     for v1,v2 in vals:
#         diff = v1 - v2
#         if abs(diff) % 2 == 0:
#             diff /= 2
#             diff = int(diff)
#             key = diff + v2
#             if key in counts:
#                 counts[key] += 1
#             else:
#                 counts[key] = 1
            

#     mx = max(counts.values())
#     # print("counts: {0}\nmax: {1}".format(counts, mx))

#     return mx


# def countCol(grid):
#     d1 = grid[0][0] - grid[1][0]
#     d2 = grid[1][0] - grid[2][0]
#     d3 = grid[0][2] - grid[1][2]
#     d4 = grid[1][2] - grid[2][2]

#     count = 1 if d1 == d2 else 0
#     count += 1 if d3 == d4 else 0

#     return count


# def countRow(row):
#     d1 = row[1] - row[0]
#     d2 = row[2] - row[1]

#     if d2 == d1:
#         return 1

#     return 0


# file = open("GooglePrep/py_a/0711square.txt", 'r')

# # t = int(input())
# t = int(file.readline().rstrip())
# solve(t)

# You are given a 3×3 grid of integers. 

# Let Gi,j denote the integer in the i-th row and j-th column of the grid, where i and j are 0-indexed. 

# The integer in the middle of the grid, G1,1, is missing. 

# Find the maximum number of rows, columns, and diagonals of this square, that form sequences which are arithmetic progressions. 
# You can replace the missing number with any integer.

# An arithmetic progression (also known as arithmetic sequence) is a sequence of numbers such that the difference between consecutive terms is constant. 
# In mathematical terms, this can be represented as an=an−1+d, where d is the common difference. 

# In this problem, a sequence can be the 3 numbers in either a row, column or diagonal. 

# We are looking to replace the missing value by an integer that maximizes the number of arithmetic progressions that can be found in the resulting set of sequences.

# Two sequences are considered different if they are from different rows, columns, or diagonals. For example, the sequence {2,4,6}
# across the middle row and {2,4,6} across the top row will be counted as two sequences but the sequences {2,4,6} and {6,4,2}
# across the same row, column, or diagonal will be counted as one sequence.

# Input
# The first line of the input gives the number of test cases, T. T test cases follow.
# Each test case consists of 3 lines.
# The first line of each test case contains 3 integers, G0,0, G0,1, and G0,2.
# The second line of each test case contains 2 integers, G1,0 and G1,2.
# The last line of each test case contains 3 integers, G2,0, G2,1, and G2,2.
# Output

# For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and 
# y is the maximum possible number of arithmetic progressions that can be generated by the rows, columns, and diagonals of the grid after setting the missing element. 

import math

def solve(testcases):

    for testcase in range(testcases):
        row1 = [int(s) for s in input().split(" ")] # read a list of integers
        row2 = [int(s) for s in input().split(" ")]
        row2.insert(1, False)
        row3 = [int(s) for s in input().split(" ")]
  
        grid = [row1, row2, row3]

        total = 0

        for i, row in enumerate(grid):

            row_count = 0
            col_count = 0
            special_count = 0
            if i != 1: 
                row_count = countRow(row)

                if i == 0:
                    col_count += countCol(grid)
            else:
                special_count = countSpecial(grid)

            total += (row_count + col_count + special_count)

        print("Case #{0}: {1}".format(testcase + 1, total))

            

def countSpecial(grid):
    counts = {}
    vals = [(grid[0][0], grid[2][2]), (grid[0][2], grid[2][0]), (grid[0][1],grid[2][1]), (grid[1][0],grid[1][2])]
    
    for v1,v2 in vals:
        diff = v1 - v2
        if abs(diff) % 2 == 0:
            diff /= 2
            diff = int(diff)
            key = diff + v2
            if key in counts:
                counts[key] += 1
            else:
                counts[key] = 1
            

    mx = max(counts.values())

    return mx


def countCol(grid):
    d1 = grid[0][0] - grid[1][0]
    d2 = grid[1][0] - grid[2][0]
    d3 = grid[0][2] - grid[1][2]
    d4 = grid[1][2] - grid[2][2]

    count = 1 if d1 == d2 else 0
    count += 1 if d3 == d4 else 0

    return count


def countRow(row):
    d1 = row[1] - row[0]
    d2 = row[2] - row[1]

    if d2 == d1:
        return 1

    return 0



t = int(input())
solve(t)
